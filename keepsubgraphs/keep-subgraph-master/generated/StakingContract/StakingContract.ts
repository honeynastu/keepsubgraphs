// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class ExpiredLockReleased extends ethereum.Event {
  get params(): ExpiredLockReleased__Params {
    return new ExpiredLockReleased__Params(this);
  }
}

export class ExpiredLockReleased__Params {
  _event: ExpiredLockReleased;

  constructor(event: ExpiredLockReleased) {
    this._event = event;
  }

  get operator(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get lockCreator(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class LockReleased extends ethereum.Event {
  get params(): LockReleased__Params {
    return new LockReleased__Params(this);
  }
}

export class LockReleased__Params {
  _event: LockReleased;

  constructor(event: LockReleased) {
    this._event = event;
  }

  get operator(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get lockCreator(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class OperatorStaked extends ethereum.Event {
  get params(): OperatorStaked__Params {
    return new OperatorStaked__Params(this);
  }
}

export class OperatorStaked__Params {
  _event: OperatorStaked;

  constructor(event: OperatorStaked) {
    this._event = event;
  }

  get operator(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get beneficiary(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get authorizer(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get value(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class RecoveredStake extends ethereum.Event {
  get params(): RecoveredStake__Params {
    return new RecoveredStake__Params(this);
  }
}

export class RecoveredStake__Params {
  _event: RecoveredStake;

  constructor(event: RecoveredStake) {
    this._event = event;
  }

  get operator(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class StakeDelegated extends ethereum.Event {
  get params(): StakeDelegated__Params {
    return new StakeDelegated__Params(this);
  }
}

export class StakeDelegated__Params {
  _event: StakeDelegated;

  constructor(event: StakeDelegated) {
    this._event = event;
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get operator(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class StakeLocked extends ethereum.Event {
  get params(): StakeLocked__Params {
    return new StakeLocked__Params(this);
  }
}

export class StakeLocked__Params {
  _event: StakeLocked;

  constructor(event: StakeLocked) {
    this._event = event;
  }

  get operator(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get lockCreator(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get until(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class StakeOwnershipTransferred extends ethereum.Event {
  get params(): StakeOwnershipTransferred__Params {
    return new StakeOwnershipTransferred__Params(this);
  }
}

export class StakeOwnershipTransferred__Params {
  _event: StakeOwnershipTransferred;

  constructor(event: StakeOwnershipTransferred) {
    this._event = event;
  }

  get operator(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newOwner(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class TokensSeized extends ethereum.Event {
  get params(): TokensSeized__Params {
    return new TokensSeized__Params(this);
  }
}

export class TokensSeized__Params {
  _event: TokensSeized;

  constructor(event: TokensSeized) {
    this._event = event;
  }

  get operator(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class TokensSlashed extends ethereum.Event {
  get params(): TokensSlashed__Params {
    return new TokensSlashed__Params(this);
  }
}

export class TokensSlashed__Params {
  _event: TokensSlashed;

  constructor(event: TokensSlashed) {
    this._event = event;
  }

  get operator(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class TopUpCompleted extends ethereum.Event {
  get params(): TopUpCompleted__Params {
    return new TopUpCompleted__Params(this);
  }
}

export class TopUpCompleted__Params {
  _event: TopUpCompleted;

  constructor(event: TopUpCompleted) {
    this._event = event;
  }

  get operator(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newAmount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class TopUpInitiated extends ethereum.Event {
  get params(): TopUpInitiated__Params {
    return new TopUpInitiated__Params(this);
  }
}

export class TopUpInitiated__Params {
  _event: TopUpInitiated;

  constructor(event: TopUpInitiated) {
    this._event = event;
  }

  get operator(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get topUp(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class Undelegated extends ethereum.Event {
  get params(): Undelegated__Params {
    return new Undelegated__Params(this);
  }
}

export class Undelegated__Params {
  _event: Undelegated;

  constructor(event: Undelegated) {
    this._event = event;
  }

  get operator(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get undelegatedAt(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class StakingContract__getDelegationInfoResult {
  value0: BigInt;
  value1: BigInt;
  value2: BigInt;

  constructor(value0: BigInt, value1: BigInt, value2: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    return map;
  }
}

export class StakingContract__getLocksResult {
  value0: Array<Address>;
  value1: Array<BigInt>;

  constructor(value0: Array<Address>, value1: Array<BigInt>) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromAddressArray(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigIntArray(this.value1));
    return map;
  }
}

export class StakingContract extends ethereum.SmartContract {
  static bind(address: Address): StakingContract {
    return new StakingContract("StakingContract", address);
  }

  activeStake(_operator: Address, _operatorContract: Address): BigInt {
    let result = super.call(
      "activeStake",
      "activeStake(address,address):(uint256)",
      [
        ethereum.Value.fromAddress(_operator),
        ethereum.Value.fromAddress(_operatorContract)
      ]
    );

    return result[0].toBigInt();
  }

  try_activeStake(
    _operator: Address,
    _operatorContract: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "activeStake",
      "activeStake(address,address):(uint256)",
      [
        ethereum.Value.fromAddress(_operator),
        ethereum.Value.fromAddress(_operatorContract)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  authorizerOf(_operator: Address): Address {
    let result = super.call("authorizerOf", "authorizerOf(address):(address)", [
      ethereum.Value.fromAddress(_operator)
    ]);

    return result[0].toAddress();
  }

  try_authorizerOf(_operator: Address): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "authorizerOf",
      "authorizerOf(address):(address)",
      [ethereum.Value.fromAddress(_operator)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  balanceOf(_address: Address): BigInt {
    let result = super.call("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(_address)
    ]);

    return result[0].toBigInt();
  }

  try_balanceOf(_address: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(_address)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  beneficiaryOf(_operator: Address): Address {
    let result = super.call(
      "beneficiaryOf",
      "beneficiaryOf(address):(address)",
      [ethereum.Value.fromAddress(_operator)]
    );

    return result[0].toAddress();
  }

  try_beneficiaryOf(_operator: Address): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "beneficiaryOf",
      "beneficiaryOf(address):(address)",
      [ethereum.Value.fromAddress(_operator)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  deployedAt(): BigInt {
    let result = super.call("deployedAt", "deployedAt():(uint256)", []);

    return result[0].toBigInt();
  }

  try_deployedAt(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("deployedAt", "deployedAt():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  eligibleStake(_operator: Address, _operatorContract: Address): BigInt {
    let result = super.call(
      "eligibleStake",
      "eligibleStake(address,address):(uint256)",
      [
        ethereum.Value.fromAddress(_operator),
        ethereum.Value.fromAddress(_operatorContract)
      ]
    );

    return result[0].toBigInt();
  }

  try_eligibleStake(
    _operator: Address,
    _operatorContract: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "eligibleStake",
      "eligibleStake(address,address):(uint256)",
      [
        ethereum.Value.fromAddress(_operator),
        ethereum.Value.fromAddress(_operatorContract)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getAuthoritySource(operatorContract: Address): Address {
    let result = super.call(
      "getAuthoritySource",
      "getAuthoritySource(address):(address)",
      [ethereum.Value.fromAddress(operatorContract)]
    );

    return result[0].toAddress();
  }

  try_getAuthoritySource(
    operatorContract: Address
  ): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getAuthoritySource",
      "getAuthoritySource(address):(address)",
      [ethereum.Value.fromAddress(operatorContract)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getDelegationInfo(
    _operator: Address
  ): StakingContract__getDelegationInfoResult {
    let result = super.call(
      "getDelegationInfo",
      "getDelegationInfo(address):(uint256,uint256,uint256)",
      [ethereum.Value.fromAddress(_operator)]
    );

    return new StakingContract__getDelegationInfoResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBigInt()
    );
  }

  try_getDelegationInfo(
    _operator: Address
  ): ethereum.CallResult<StakingContract__getDelegationInfoResult> {
    let result = super.tryCall(
      "getDelegationInfo",
      "getDelegationInfo(address):(uint256,uint256,uint256)",
      [ethereum.Value.fromAddress(_operator)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new StakingContract__getDelegationInfoResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBigInt()
      )
    );
  }

  getLocks(operator: Address): StakingContract__getLocksResult {
    let result = super.call(
      "getLocks",
      "getLocks(address):(address[],uint256[])",
      [ethereum.Value.fromAddress(operator)]
    );

    return new StakingContract__getLocksResult(
      result[0].toAddressArray(),
      result[1].toBigIntArray()
    );
  }

  try_getLocks(
    operator: Address
  ): ethereum.CallResult<StakingContract__getLocksResult> {
    let result = super.tryCall(
      "getLocks",
      "getLocks(address):(address[],uint256[])",
      [ethereum.Value.fromAddress(operator)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new StakingContract__getLocksResult(
        value[0].toAddressArray(),
        value[1].toBigIntArray()
      )
    );
  }

  hasMinimumStake(staker: Address, operatorContract: Address): boolean {
    let result = super.call(
      "hasMinimumStake",
      "hasMinimumStake(address,address):(bool)",
      [
        ethereum.Value.fromAddress(staker),
        ethereum.Value.fromAddress(operatorContract)
      ]
    );

    return result[0].toBoolean();
  }

  try_hasMinimumStake(
    staker: Address,
    operatorContract: Address
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "hasMinimumStake",
      "hasMinimumStake(address,address):(bool)",
      [
        ethereum.Value.fromAddress(staker),
        ethereum.Value.fromAddress(operatorContract)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  initializationPeriod(): BigInt {
    let result = super.call(
      "initializationPeriod",
      "initializationPeriod():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_initializationPeriod(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "initializationPeriod",
      "initializationPeriod():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  isApprovedOperatorContract(_operatorContract: Address): boolean {
    let result = super.call(
      "isApprovedOperatorContract",
      "isApprovedOperatorContract(address):(bool)",
      [ethereum.Value.fromAddress(_operatorContract)]
    );

    return result[0].toBoolean();
  }

  try_isApprovedOperatorContract(
    _operatorContract: Address
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isApprovedOperatorContract",
      "isApprovedOperatorContract(address):(bool)",
      [ethereum.Value.fromAddress(_operatorContract)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isAuthorizedForOperator(
    _operator: Address,
    _operatorContract: Address
  ): boolean {
    let result = super.call(
      "isAuthorizedForOperator",
      "isAuthorizedForOperator(address,address):(bool)",
      [
        ethereum.Value.fromAddress(_operator),
        ethereum.Value.fromAddress(_operatorContract)
      ]
    );

    return result[0].toBoolean();
  }

  try_isAuthorizedForOperator(
    _operator: Address,
    _operatorContract: Address
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isAuthorizedForOperator",
      "isAuthorizedForOperator(address,address):(bool)",
      [
        ethereum.Value.fromAddress(_operator),
        ethereum.Value.fromAddress(_operatorContract)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isStakeLocked(operator: Address): boolean {
    let result = super.call("isStakeLocked", "isStakeLocked(address):(bool)", [
      ethereum.Value.fromAddress(operator)
    ]);

    return result[0].toBoolean();
  }

  try_isStakeLocked(operator: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isStakeLocked",
      "isStakeLocked(address):(bool)",
      [ethereum.Value.fromAddress(operator)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  minimumStake(): BigInt {
    let result = super.call("minimumStake", "minimumStake():(uint256)", []);

    return result[0].toBigInt();
  }

  try_minimumStake(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("minimumStake", "minimumStake():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  ownerOf(_operator: Address): Address {
    let result = super.call("ownerOf", "ownerOf(address):(address)", [
      ethereum.Value.fromAddress(_operator)
    ]);

    return result[0].toAddress();
  }

  try_ownerOf(_operator: Address): ethereum.CallResult<Address> {
    let result = super.tryCall("ownerOf", "ownerOf(address):(address)", [
      ethereum.Value.fromAddress(_operator)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  undelegationPeriod(): BigInt {
    let result = super.call(
      "undelegationPeriod",
      "undelegationPeriod():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_undelegationPeriod(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "undelegationPeriod",
      "undelegationPeriod():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get _token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _tokenGrant(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _escrow(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get _registry(): Address {
    return this._call.inputValues[3].value.toAddress();
  }

  get _initializationPeriod(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class AuthorizeOperatorContractCall extends ethereum.Call {
  get inputs(): AuthorizeOperatorContractCall__Inputs {
    return new AuthorizeOperatorContractCall__Inputs(this);
  }

  get outputs(): AuthorizeOperatorContractCall__Outputs {
    return new AuthorizeOperatorContractCall__Outputs(this);
  }
}

export class AuthorizeOperatorContractCall__Inputs {
  _call: AuthorizeOperatorContractCall;

  constructor(call: AuthorizeOperatorContractCall) {
    this._call = call;
  }

  get _operator(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _operatorContract(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class AuthorizeOperatorContractCall__Outputs {
  _call: AuthorizeOperatorContractCall;

  constructor(call: AuthorizeOperatorContractCall) {
    this._call = call;
  }
}

export class CancelStakeCall extends ethereum.Call {
  get inputs(): CancelStakeCall__Inputs {
    return new CancelStakeCall__Inputs(this);
  }

  get outputs(): CancelStakeCall__Outputs {
    return new CancelStakeCall__Outputs(this);
  }
}

export class CancelStakeCall__Inputs {
  _call: CancelStakeCall;

  constructor(call: CancelStakeCall) {
    this._call = call;
  }

  get _operator(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class CancelStakeCall__Outputs {
  _call: CancelStakeCall;

  constructor(call: CancelStakeCall) {
    this._call = call;
  }
}

export class ClaimDelegatedAuthorityCall extends ethereum.Call {
  get inputs(): ClaimDelegatedAuthorityCall__Inputs {
    return new ClaimDelegatedAuthorityCall__Inputs(this);
  }

  get outputs(): ClaimDelegatedAuthorityCall__Outputs {
    return new ClaimDelegatedAuthorityCall__Outputs(this);
  }
}

export class ClaimDelegatedAuthorityCall__Inputs {
  _call: ClaimDelegatedAuthorityCall;

  constructor(call: ClaimDelegatedAuthorityCall) {
    this._call = call;
  }

  get delegatedAuthoritySource(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class ClaimDelegatedAuthorityCall__Outputs {
  _call: ClaimDelegatedAuthorityCall;

  constructor(call: ClaimDelegatedAuthorityCall) {
    this._call = call;
  }
}

export class CommitTopUpCall extends ethereum.Call {
  get inputs(): CommitTopUpCall__Inputs {
    return new CommitTopUpCall__Inputs(this);
  }

  get outputs(): CommitTopUpCall__Outputs {
    return new CommitTopUpCall__Outputs(this);
  }
}

export class CommitTopUpCall__Inputs {
  _call: CommitTopUpCall;

  constructor(call: CommitTopUpCall) {
    this._call = call;
  }

  get _operator(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class CommitTopUpCall__Outputs {
  _call: CommitTopUpCall;

  constructor(call: CommitTopUpCall) {
    this._call = call;
  }
}

export class LockStakeCall extends ethereum.Call {
  get inputs(): LockStakeCall__Inputs {
    return new LockStakeCall__Inputs(this);
  }

  get outputs(): LockStakeCall__Outputs {
    return new LockStakeCall__Outputs(this);
  }
}

export class LockStakeCall__Inputs {
  _call: LockStakeCall;

  constructor(call: LockStakeCall) {
    this._call = call;
  }

  get operator(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get duration(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class LockStakeCall__Outputs {
  _call: LockStakeCall;

  constructor(call: LockStakeCall) {
    this._call = call;
  }
}

export class ReceiveApprovalCall extends ethereum.Call {
  get inputs(): ReceiveApprovalCall__Inputs {
    return new ReceiveApprovalCall__Inputs(this);
  }

  get outputs(): ReceiveApprovalCall__Outputs {
    return new ReceiveApprovalCall__Outputs(this);
  }
}

export class ReceiveApprovalCall__Inputs {
  _call: ReceiveApprovalCall;

  constructor(call: ReceiveApprovalCall) {
    this._call = call;
  }

  get _from(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _value(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get _token(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get _extraData(): Bytes {
    return this._call.inputValues[3].value.toBytes();
  }
}

export class ReceiveApprovalCall__Outputs {
  _call: ReceiveApprovalCall;

  constructor(call: ReceiveApprovalCall) {
    this._call = call;
  }
}

export class RecoverStakeCall extends ethereum.Call {
  get inputs(): RecoverStakeCall__Inputs {
    return new RecoverStakeCall__Inputs(this);
  }

  get outputs(): RecoverStakeCall__Outputs {
    return new RecoverStakeCall__Outputs(this);
  }
}

export class RecoverStakeCall__Inputs {
  _call: RecoverStakeCall;

  constructor(call: RecoverStakeCall) {
    this._call = call;
  }

  get _operator(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class RecoverStakeCall__Outputs {
  _call: RecoverStakeCall;

  constructor(call: RecoverStakeCall) {
    this._call = call;
  }
}

export class ReleaseExpiredLockCall extends ethereum.Call {
  get inputs(): ReleaseExpiredLockCall__Inputs {
    return new ReleaseExpiredLockCall__Inputs(this);
  }

  get outputs(): ReleaseExpiredLockCall__Outputs {
    return new ReleaseExpiredLockCall__Outputs(this);
  }
}

export class ReleaseExpiredLockCall__Inputs {
  _call: ReleaseExpiredLockCall;

  constructor(call: ReleaseExpiredLockCall) {
    this._call = call;
  }

  get operator(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get operatorContract(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class ReleaseExpiredLockCall__Outputs {
  _call: ReleaseExpiredLockCall;

  constructor(call: ReleaseExpiredLockCall) {
    this._call = call;
  }
}

export class SeizeCall extends ethereum.Call {
  get inputs(): SeizeCall__Inputs {
    return new SeizeCall__Inputs(this);
  }

  get outputs(): SeizeCall__Outputs {
    return new SeizeCall__Outputs(this);
  }
}

export class SeizeCall__Inputs {
  _call: SeizeCall;

  constructor(call: SeizeCall) {
    this._call = call;
  }

  get amountToSeize(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get rewardMultiplier(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get tattletale(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get misbehavedOperators(): Array<Address> {
    return this._call.inputValues[3].value.toAddressArray();
  }
}

export class SeizeCall__Outputs {
  _call: SeizeCall;

  constructor(call: SeizeCall) {
    this._call = call;
  }
}

export class SlashCall extends ethereum.Call {
  get inputs(): SlashCall__Inputs {
    return new SlashCall__Inputs(this);
  }

  get outputs(): SlashCall__Outputs {
    return new SlashCall__Outputs(this);
  }
}

export class SlashCall__Inputs {
  _call: SlashCall;

  constructor(call: SlashCall) {
    this._call = call;
  }

  get amountToSlash(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get misbehavedOperators(): Array<Address> {
    return this._call.inputValues[1].value.toAddressArray();
  }
}

export class SlashCall__Outputs {
  _call: SlashCall;

  constructor(call: SlashCall) {
    this._call = call;
  }
}

export class TransferStakeOwnershipCall extends ethereum.Call {
  get inputs(): TransferStakeOwnershipCall__Inputs {
    return new TransferStakeOwnershipCall__Inputs(this);
  }

  get outputs(): TransferStakeOwnershipCall__Outputs {
    return new TransferStakeOwnershipCall__Outputs(this);
  }
}

export class TransferStakeOwnershipCall__Inputs {
  _call: TransferStakeOwnershipCall;

  constructor(call: TransferStakeOwnershipCall) {
    this._call = call;
  }

  get operator(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get newOwner(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class TransferStakeOwnershipCall__Outputs {
  _call: TransferStakeOwnershipCall;

  constructor(call: TransferStakeOwnershipCall) {
    this._call = call;
  }
}

export class UndelegateCall extends ethereum.Call {
  get inputs(): UndelegateCall__Inputs {
    return new UndelegateCall__Inputs(this);
  }

  get outputs(): UndelegateCall__Outputs {
    return new UndelegateCall__Outputs(this);
  }
}

export class UndelegateCall__Inputs {
  _call: UndelegateCall;

  constructor(call: UndelegateCall) {
    this._call = call;
  }

  get _operator(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class UndelegateCall__Outputs {
  _call: UndelegateCall;

  constructor(call: UndelegateCall) {
    this._call = call;
  }
}

export class UndelegateAtCall extends ethereum.Call {
  get inputs(): UndelegateAtCall__Inputs {
    return new UndelegateAtCall__Inputs(this);
  }

  get outputs(): UndelegateAtCall__Outputs {
    return new UndelegateAtCall__Outputs(this);
  }
}

export class UndelegateAtCall__Inputs {
  _call: UndelegateAtCall;

  constructor(call: UndelegateAtCall) {
    this._call = call;
  }

  get _operator(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _undelegationTimestamp(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class UndelegateAtCall__Outputs {
  _call: UndelegateAtCall;

  constructor(call: UndelegateAtCall) {
    this._call = call;
  }
}

export class UnlockStakeCall extends ethereum.Call {
  get inputs(): UnlockStakeCall__Inputs {
    return new UnlockStakeCall__Inputs(this);
  }

  get outputs(): UnlockStakeCall__Outputs {
    return new UnlockStakeCall__Outputs(this);
  }
}

export class UnlockStakeCall__Inputs {
  _call: UnlockStakeCall;

  constructor(call: UnlockStakeCall) {
    this._call = call;
  }

  get operator(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class UnlockStakeCall__Outputs {
  _call: UnlockStakeCall;

  constructor(call: UnlockStakeCall) {
    this._call = call;
  }
}
